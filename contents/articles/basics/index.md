---
title: basics
date: 2010-03-14
author: igor
template: article.jade
---
# Basics
I'm about to extend my activities as trainer, but lately I have come to realize more and more that sometimes I'm having a hard time explaining myself. The reason to this is what I consider basics.

I strongly believe in a holistic approach. When someone asks a question I try to explain as much of the background as possible, so they can begin to comprehend how a system is composed and how it works together.

Maybe some day you'll be in the unlucky position to receive training from me in some form or the other. So as to prepare you mentally, I'm putting here down some of the things I wasted my time with.

I spent the maximum possible 7 years in a 5 year school without finishing it. Most of the time I learned stuff I cared about or worked on interesting projects or just worked for \$\$\$. But I did learn some useful things even from my teachers!

Starting with bits and why which platform has how many bits for a byte/word/double word/quad word.. How to add/subtract/multiply/divide two binary integers and floating point numbers (I forgot the latter by now, for reasons of sanity, I suppose). I learned how and why bits are transfered over copper, optical fibres and, to certain extent, air.

In the first couple of years I also learned programming basics and then taught myself C and later learned in school how important it is to sanitize input, when your collegues are testing your programs by hammering on the keyboard. We also learned algorithm basics, (boolean, predicated and fuzzy) logic, database concepts and their schematic and mathematic background and OOP concepts.

In my second year I learned Operating System Basics (Operating Systems: Design and Implementation) from Tanenbaum and shortly after Compiler Theory from the Dragon Book.

Meanwhile I got exposed to a number of Programming Languages in school. All in all I have so far learned, programmed in (and forgotten about): C, C++, Java, Pascal, ObjectPascal (Delphi), PL/I, PHP, Bash, JCL, Tlc, Erlang, Lua, Pike, Perl and ABAP. I've had contact to different Assemblers too: MicroChip Assembler, IBM 360, Intel/AMD and Motorola 68k.

I followed Jack Crenshaw's Let's build a Compiler, translating it from Pascal to C and from Motorola 68k to Intel. After that I got interested in Formal Languages which inspired me to design and specify my own in EBNF, naming it "Y". I gave up on the design when I realized how close it was comming to that of PL/I. brrrr...

After that a friend of mine and me decided it's high-time we learn how to implement a (micro) kernel, and did that with `OCB" (Operating-system Concept`B", after tossing away concept A). OCB was implemented in object oriented C and minimally in Assembler, where necessary. I even held a presentation on it in school, teaching myself LaTeX to write the OS' documentation and the presentation. (It really helps a lot if you know compiler theory, when the LaTeX compiler throws cryptic errors in files which don't contain any errors.)

I then got interested in AI, but unfortunately I wasn't able to get anything out of this very broad and complex field other than pure basics. (Neural networks, fuzzy logic, etc..)

After the third year in school we had the chance to choose between three different directions. Having been exposed to PL/I and knowing that COBOL awaited in the `Commercial" fraction, and being generally very untalented with graphics and`Multimedia" on computers (Linux), I opted for the "Networking" fraction.

Among other things, we all made our CCNA certification. But the really "cool" kids stayed longer and worked on projects to represent the school for new-commers. Learning CCNP level stuff, theoretically (why certain MAC and IP addresses are reserved, how they're mapped together and what they're used for, learning about Frame Relay, MPLS and ATM, WAN Routing and Loadbalancing with Switches), as well as practiacally (like configuring routers and pixen redundantly and making your Asterisk play nice with your Catalyst (Cisco) power-over-ethernet switches).

I also learned that among the voodoo of IT topics cross compiling software is the black-mgaic fairy-dusted dragon-unicorn. (Only much later, when I did a little side project to learn how to create a Linux distro from LFS, did I appreciate how invaluable the experience from cross-compiling was.)

It must also have been in those networking years that I took a course on programming Linux Drivers. I got to know a number of people. Some of them were younger others were older, but all of them were terribly smart. They made me feel very stupid at times...
